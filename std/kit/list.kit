/**
 * A List[T] is an immutable singly linked list.
 */
enum List[T] {
    Cons(head: T, tail: List[T]);
    Empty;

    /**
     * Returns a new list which combines two other lists. Requires iterating
     * over both lists, which is O(n).
     */
    public function concat(other: Self[T]): Self[T] {
        var list = Empty;
        for i in this {
            list = i :: list;
        }
        for i in other {
            list = i :: list;
        }
        return list.reverse();
    }

    /**
     * Returns a new list, with the provided value added to the front of this
     * list.
     */
    public function cons(value: T): Self[T] {
        return Cons(value, this);
    }

    /**
     * Return a new list, which is this list in reverse order. Requires O(n)
     * time. This does not modify the current list.
     */
    public function reverse(): Self[T] {
        var list = Empty;
        for i in this {
            list = i :: list;
        }
        return list;
    }

    /**
     * Return the length of the list. Requires O(n) to calculate.
     */
    public function getLength(): Uint {
        var len = 0;
        var current = this;
        while true {
            match current {
                Cons(h, t) => {
                    ++len;
                    current = t;
                }
                Empty => break;
            }
        }
        return len;
    }

    public rules {
        (this.length) => this.getLength();

        /**
         * Returns the first element of this list if the list is not empty, or None
         * otherwise.
         */
        (this.head) => match this {
            Cons(h, t) => Some(h);
            Empty => None;
        }

        /**
         * Returns the list without its first element. If the list is already empty,
         * returns an empty list.
         */
        (this.tail) => match this {
            Cons(h, t) => t;
            Empty => Empty;
        }

        /**
         * Check whether the list is empty in constant time.
         */
        (this.empty) => match this {
            Empty => true;
            default => false;
        }

        ((it: Iterable[T]) as Self[T]) => {
            var list = Empty;
            for i in it {
                list = i :: list;
            }
            list.reverse();
        }

        /**
         * Use the cons operator to construct a list out of individual values:
         *
         *     var myList = 1 :: 2 :: 3 :: Empty;
         *
         * The cons operator is right associative, so this parses as:
         *
         *     var mList = 1 :: (2 :: (3 :: Empty));
         */
        ((head: T)::(tail: Self[T])) => Cons(head, tail);

        // optimize List iteration at compile time when the type is known
        (for $ident in this {$e;}) => {
            var __rest = this;
            while !__rest.empty {
                var $ident = __rest.head;
                $e;
                __rest = __rest.tail;
            }
        }
    }
}

implement Iterable[T] for List[T] {
    public function iterator() {
        return new ListIterator(this);
    }
}

struct ListIterator[T] {
    public var current: List[T];

    public function new(list: Ref[List[T]]) {
        this.current = list;
    }
}

implement Iterator[T] for ArrayIterator[T] {
    public function next(): Null[T] {
        return match list {
            Cons(h, t) => {
                current = t;
                Some(h);
            }
            Empty => None;
        }
    }
}
